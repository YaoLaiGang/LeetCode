package minimizeMalwareSpreadII;

public class Solution {
    /*
    * 这个问题的意思是，有个一网络结构(无向图)，其中有几个病毒节点，这几个病毒节点会传播和它相邻的点直到不能传播
    * 现在可以清除其中的一个点，问清除哪个点感染的比较少
    * 1.使用DFS暴力求解，也就是每次每次删除一个感染点然后以其它节点为出发点并记录感染数
    * 2.使用并查集方法类似
    * */
    private int[][] graph;
    private boolean[] visited;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        this.graph = graph;
        visited = new boolean[graph.length];
        int minMal=Integer.MAX_VALUE, minIdnex=-1;
        for (int del :
                initial) {
            visited[del] = true; // 删除其中的一个点
            int mal = 0;
            for (int v :
                    initial) {
                if (!visited[v]){
                    mal+=dfs(v);
                }
            }
            for (int i = 0; i < visited.length; i++) {
                visited[i] = false;
            }
            if (mal<minMal){
                minMal = mal;
                minIdnex = del;
            }else if (mal==minMal){
                minIdnex = Math.min(minIdnex, del);
            }
        }
        return minIdnex;
    }
    private int dfs(int start){
        visited[start] = true;
        int num=1;
        for (int i = 0; i < graph.length; i++) {
            if (graph[start][i]==1){
                if (visited[i]) continue;
                num+=dfs(i);
            }
        }
        return num;
    }

    public static void main(String[] args) {
        int[][] graph = {{1,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0},{0,0,1,0,1,0,1,0,0},{0,0,0,1,0,0,0,0,0},{0,0,1,0,1,0,0,0,0},
                {0,0,0,0,0,1,0,0,0},{0,0,1,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,1}};
        int[] initial = {6,0,4};
        System.out.println((new Solution()).minMalwareSpread(graph, initial));
    }
}
